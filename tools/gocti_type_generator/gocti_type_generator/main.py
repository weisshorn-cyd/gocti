import argparse
import os
import sys
from dataclasses import dataclass
from pathlib import Path
from string import Template

from dotenv import load_dotenv
from pycti import OpenCTIApiClient
from rich import print

from gocti_type_generator import utils
from gocti_type_generator.entity import Entity, GraphQLQueryArg, list_graphql_queries
from gocti_type_generator.type import GRAPHQL_TYPES_PKG_NAME, InputValue, Type

BASE_ENTITIES: list[str] = [
    "AttackPattern",
    "Campaign",
    "CaseIncident",
    "CaseRfi",
    "CaseRft",
    "Channel",
    "CourseOfAction",
    "DataComponent",
    "DataSource",
    "Event",
    "ExternalReference",
    "Feedback",
    "Grouping",
    "Identity",
    "Incident",
    "Indicator",
    "Infrastructure",
    "IntrusionSet",
    "KillChainPhase",
    "Label",
    "Language",
    "Location",
    "Malware",
    "MalwareAnalysis",
    "MarkingDefinition",
    "Narrative",
    "Note",
    "ObservedData",
    "Opinion",
    "Report",
    "Task",
    "ThreatActor",
    "ThreatActorGroup",
    "ThreatActorIndividual",
    "Tool",
    "Vocabulary",
    "Vulnerability",
]
LOW_LEVEL_ENTITIES: list[str] = [
    "StixCoreObject",
    "StixCoreRelationship",
    "StixCyberObservable",
    "StixDomainObject",
]
SYSTEM_ENTITIES: list[str] = [
    "Capability",
    "CaseTemplate",
    "Group",
    "Role",
    "StatusTemplate",
    "SubType",
    "TaskTemplate",
    "User",
]

GENERATED_FILE_HEADER = """
// Code generated by '/tools/gocti_type_generator' for OpenCTI version {opencti_version} - DO NOT EDIT.
""".strip()

GO_CODE_HEADER = """
package $pkg

import (
$imports
)""".strip()

LIST_OPTIONS_GO_TMPL = """
const (
	defaultSearch    = ""
	defaultFirst     = 1000
	defaultAfter     = ""
	defaultOrderBy   = "created_at"
	defaultOrderMode = OrderModeAsc
)

// QueryVars is a list of parameters to configure a GraphQL List query.
// Configuration should be made via [Option] functions.
type QueryVars struct {
	// Shared variables for most Entities

	Filters   FilterGroup  `json:"filters"`
	Search    string       `json:"search,omitempty"`
	First     int          `json:"first,omitempty"`   // Number of entities per page
	After     string       `json:"after,omitempty"`   // EndCursor of previous page
	OrderBy   string       `json:"orderBy,omitempty"` // Specific to each entity
	OrderMode OrderingMode `json:"orderMode"`

	// Entity-dependent variables

    $QueryVarFields
}

// Mapping converts the List Query Variables struct to a map[string]any
func (queryVars *QueryVars) Mapping() (map[string]any, error) {
	mapping := map[string]any{}

    // Json is used instead of mapstructure to utilize the custom MarshalJSON methods.
	jsonBytes, err := json.Marshal(queryVars)
	if err != nil {
		return nil, fmt.Errorf("marshalling query vars: %w", err)
	}

	if err := json.Unmarshal(jsonBytes, &mapping); err != nil {
		return nil, fmt.Errorf("unmarshalling query vars: %w", err)
	}

	return mapping, nil
}

// NewQueryVars returns a [QueryVars] instance with default values applied.
func NewQueryVars() *QueryVars {
	// Apply default shared values
	output := &QueryVars{
		Filters:   FilterGroup{},
		Search:    defaultSearch,
		First:     defaultFirst,
		After:     defaultAfter,
		OrderBy:   defaultOrderBy,
		OrderMode: defaultOrderMode,
	}

	return output
}

// Option is a function that configures a [QueryVars] object.
type Option func(*QueryVars)

// Declarations of all the With... functions.
""".strip()

WITH_FUNCTION_GO_TMPL = """
func With$Field($field $FieldType) Option {
    return func(vars *QueryVars) {
        vars.$Field = $field
    }
}""".strip()

GOCTI_REPO = "GOCTI_REPO"
OPENCTI_URL = "OPENCTI_URL"
OPENCTI_TOKEN = "OPENCTI_TOKEN"


@dataclass
class Config:
    repo: Path
    url: str
    token: str
    client: OpenCTIApiClient
    graphql_queries: dict[str, GraphQLQueryArg]


def load_config() -> Config:
    # Read arguments
    parser = argparse.ArgumentParser(
        description="Tool to generate the most common entities queried with Gocti.",
    )
    # Optional args
    parser.add_argument("--env", default=None, type=Path)
    # Config args
    parser.add_argument("-u", "--url", default=None, type=str)
    parser.add_argument("-t", "--token", default=None, type=str)
    parser.add_argument("-r", "--repo", default=None, type=Path)

    args = vars(parser.parse_args())

    # Load Environment
    if args["env"] is not None:
        dotenv_file = Path(args["env"])
        if not dotenv_file.exists():
            raise FileNotFoundError(f"Cannot find .env file: '{dotenv_file}'")
        load_dotenv(dotenv_path=args["env"])

    # Read Env Vars
    repo = os.getenv(GOCTI_REPO, args["repo"])
    url = os.getenv(OPENCTI_URL, args["url"])
    token = os.getenv(OPENCTI_TOKEN, args["token"])

    repo = Path(repo if repo else ".").resolve()
    url = str(url if url else "http://localhost:8080")
    token = str(token if token else "")
    client = OpenCTIApiClient(url=url, token=token, log_level="error")
    graphql_queries = list_graphql_queries(client=client)

    # Checking go.mod file for module name
    go_mod = Path(repo, "go.mod")
    if not go_mod.exists():
        raise FileNotFoundError(f"Cannot find go.mod file at: '{go_mod}'")
    with open(go_mod, "r") as f:
        mod_name = f.readline().split("/")[-1].strip()
    if mod_name != "gocti":
        raise FileNotFoundError(
            f"Cannot find GoCTI repository at: '{repo}', found module '{mod_name}'"
        )

    return Config(
        repo=repo,
        url=url,
        token=token,
        client=client,
        graphql_queries=graphql_queries,
    )


def delete_generated_files(cfg: Config) -> None:
    """Remove all generated files from the repo"""

    generated_header = GENERATED_FILE_HEADER.split("{")[0]

    all_go_files = list(Path.rglob(cfg.repo, "*.go"))
    for go_file in all_go_files:
        with open(go_file, "r") as f:
            if generated_header in f.read():
                os.remove(go_file)

    all_query_folders = list(Path.rglob(cfg.repo, "create_queries"))
    all_query_folders += list(Path.rglob(cfg.repo, "default_properties"))
    all_query_folders += list(Path.rglob(cfg.repo, "list_queries"))
    for query_folder in all_query_folders:
        for file in os.listdir(query_folder):
            os.remove(Path(query_folder, file))


def build_generated_file_header(cfg: Config) -> str:
    answer: dict = {}

    try:
        answer = cfg.client.query(
            """
                    query {
                        about {
                        version
                        }
                    }
                    """
        )

        opencti_version = answer["data"]["about"]["version"]
    except Exception as err:
        raise Exception("Failed to query OpenCTI version") from err

    return GENERATED_FILE_HEADER.format(opencti_version=opencti_version)


def declare_custom_types(cfg: Config) -> list[Type]:
    """Populates the Type.known_types dict with custom types."""
    type_list = []

    # GroupingContext
    t = Type.from_name(cfg.client, "GroupingContext", custom=True)
    Type.known_types[t.name] = t
    t.add_enum_values(
        [
            "malware-analysis",
            "suspicious-activity",
            "unspecified",
        ]
    )
    type_list.append(t)

    # IndicatorType
    t = Type.from_name(cfg.client, "IndicatorType", custom=True)
    Type.known_types[t.name] = t
    t.add_enum_values(
        [
            "anomalous-activity",
            "anonymization",
            "attribution",
            "benign",
            "compromised",
            "malicious-activity",
            "unknown",
        ]
    )
    type_list.append(t)

    # OpinionType
    t = Type.from_name(cfg.client, "OpinionType", custom=True)
    Type.known_types[t.name] = t
    t.add_enum_values(
        [
            "strongly-disagree",
            "disagree",
            "neutral",
            "agree",
            "strongly-agree",
        ]
    )
    type_list.append(t)

    # PatternType
    t = Type.from_name(cfg.client, "PatternType", custom=True)
    Type.known_types[t.name] = t
    t.add_enum_values(
        [
            "eql",
            "pcre",
            "shodan",
            "sigma",
            "snort",
            "spl",
            "stix",
            "suricata",
            "tanium-signal",
            "yara",
        ]
    )
    type_list.append(t)

    # Platform
    t = Type.from_name(cfg.client, "Platform", custom=True)
    Type.known_types[t.name] = t
    t.add_enum_values(
        [
            "android",
            "linux",
            "macos",
            "windows",
        ]
    )
    type_list.append(t)

    # ReportType
    t = Type.from_name(cfg.client, "ReportType", custom=True)
    Type.known_types[t.name] = t
    t.add_enum_values(
        [
            "internal-report",
            "threat-report",
        ]
    )
    type_list.append(t)

    # StixCyberObservableType
    t = Type.from_name(cfg.client, "StixCyberObservableType", custom=True)
    Type.known_types[t.name] = t
    t.add_enum_values(
        [
            "Autonomous-System",
            "Directory",
            "Domain-Name",
            "Email-Addr",
            "Email-Message",
            "Email-Mime-Part-Type",
            "Artifact",
            "File",
            "X509-Certificate",
            "IPv4-Addr",
            "IPv6-Addr",
            "Mac-Addr",
            "Mutex",
            "Network-Traffic",
            "Process",
            "Software",
            "Url",
            "User-Account",
            "Windows-Registry-Key",
            "Windows-Registry-Value-Type",
            "Hostname",
            "Cryptographic-Key",
            "Cryptocurrency-Wallet",
            "Text",
            "User-Agent",
            "Bank-Account",
            "Phone-Number",
            "Payment-Card",
            "Media-Content",
            "Simple-Observable",
        ]
    )
    type_list.append(t)

    # ConfidenceLevelOverrideInput
    t = Type.from_name(cfg.client, "ConfidenceLevelOverrideInput", custom=True)
    Type.known_types[t.name] = t
    t.add_input_fields(
        [
            InputValue(
                name="entity_type",
                opencti_type=Type.from_name(cfg.client, "String"),
            ),
            InputValue(
                name="max_confidence",
                opencti_type=Type.from_name(cfg.client, "Int"),
            ),
        ]
    )

    # ConfidenceLevelInput
    t = Type.from_name(cfg.client, "ConfidenceLevelInput", custom=True)
    Type.known_types[t.name] = t
    t.add_input_fields(
        [
            InputValue(
                name="max_confidence",
                opencti_type=Type.from_name(cfg.client, "Int"),
            ),
            InputValue(
                name="overrides",
                opencti_type=Type.from_name(
                    cfg.client,
                    "ConfidenceLevelOverrideInput",
                ),
            ),
        ]
    )
    type_list.append(t)

    # Filter
    t = Type.from_name(cfg.client, "Filter")
    Type.known_types[t.name].is_custom = True
    Type.known_types[t.name].pkg = "list"

    # FilterGroup
    t = Type.from_name(cfg.client, "FilterGroup")
    Type.known_types[t.name].is_custom = True
    Type.known_types[t.name].pkg = "list"

    # OrderingMode
    t = Type.from_name(cfg.client, "OrderingMode")
    Type.known_types[t.name].is_custom = True
    Type.known_types[t.name].pkg = "list"

    return type_list


def write_entities(
    generated_file_header: str, entities: list[Entity], pkg: str, gocti_repo: Path
) -> None:
    """Writes the list of entities and their complementary files to the GoCTI repository."""
    entities_folder = Path(gocti_repo, pkg)

    # Remove entities from the folder
    for file in os.listdir(entities_folder):
        if file.startswith("opencti_"):
            Path.unlink(Path(entities_folder, file))

    # Resolve entities
    for entity in entities:
        # Get the main file content + write all embedded files.
        entity_file_content = entity.get_file_txt(write_folder=entities_folder)

        # Write the entity file itself.
        filepath = Path(entities_folder, entity.filename)
        with open(filepath, "w") as f:
            f.write(generated_file_header + "\n\n" + entity_file_content + "\n")


def write_graphql_types(
    generated_file_header: str, entities: list[Entity], gocti_repo: Path
) -> None:
    """Writes the list of all GraphQL types used within the GoCTI repository.
    The entities and types in [entity] and [system] are meant to be wrappers around those base types.
    """
    imports: dict[str, bool] = {'"github.com/goccy/go-json"': True}
    types_to_write: dict[str, Type] = {}
    type_declarations: list[str] = []

    for entity in entities:
        types_to_write = types_to_write | entity.resolve_type_dependencies()
    types_to_write = dict(sorted(types_to_write.items()))

    for v in types_to_write.values():
        if v.is_custom:
            continue
        imports = imports | v.resolve_imports()
        type_declarations.append(v.go_write(["gocti", "json"], with_null_marshal=True))

    imports.pop(f'"github.com/weisshorn-cyd/gocti/{GRAPHQL_TYPES_PKG_NAME}"', "")

    # Write the types.go file itself.
    if len(type_declarations) > 0:
        with open(Path(gocti_repo, GRAPHQL_TYPES_PKG_NAME, "types.go"), "w") as f:
            imports = utils.format_go_imports([[i] for i in imports])

            f.write(
                generated_file_header
                + "\n\n"
                + Template(GO_CODE_HEADER).substitute(
                    pkg=GRAPHQL_TYPES_PKG_NAME, imports=imports
                )
                + "\n\n"
                + "\n\n".join(type_declarations)
                + "\n"
            )


def write_list_options(
    generated_file_header: str,
    client: OpenCTIApiClient,
    entity_list: list[Entity],
    filepath: Path,
) -> None:
    """Writes the list.options.go file."""

    query_vars: dict[str, GraphQLQueryArg] = {}
    for e in entity_list:
        if e.list_query is None:
            continue

        # Get all list query arguments, and process some exceptions
        for arg in e.list_query.args.values():
            # Avoid the main '[Entity]sOrdering' enums
            if arg.name == "orderBy":
                arg.type_name = "String"

            # Workaround similar argument names with different types
            # for the [StixCore / StixNestedRef / StixSighting] - relationships
            if arg.name in [
                "fromOrToId",
                "fromId",
                "toId",
            ] and arg.type_name.startswith("["):
                arg.alias = arg.name + "List"

            # Store all arguments
            name = arg.alias if arg.alias != "" else arg.name
            if name not in query_vars:
                # Resolve types here
                arg.resolved_type = Type.from_name(client, arg.type_name)
                query_vars[name] = arg
            elif query_vars[name].type_name != arg.type_name:
                raise ValueError(
                    f"{e} has conflicting list options: {name} = {arg.type_name} != {query_vars[name].type_name}"
                )

    query_vars = dict(sorted(query_vars.items()))

    # Put the file together
    imports = utils.format_go_imports(
        [
            ['"fmt"', '"time"'],
            ['"github.com/goccy/go-json"'],
        ]
    )
    query_var_fields = [
        Template('$FieldName $FieldType `json:"$field,omitempty"`$nolint').substitute(
            FieldName=utils.go_name(arg.alias if arg.alias != "" else arg.name),
            FieldType=arg.resolved_type.go_type(target_pkg="list", full=True),
            field=arg.name,
            nolint=" //nolint:govet // On purpose." if arg.alias != "" else "",
        )
        for arg in query_vars.values()
        if arg.name
        not in ["filters", "search", "first", "after", "orderBy", "orderMode"]
    ]
    file = (
        generated_file_header
        + "\n\n"
        + Template(GO_CODE_HEADER).substitute(
            pkg="list",
            imports=imports,
        )
        + "\n\n"
        + Template(LIST_OPTIONS_GO_TMPL).substitute(
            QueryVarFields="\n\t".join(query_var_fields),
        )
    )

    # Append the 'With' function declarations
    for arg in query_vars.values():
        field_name = utils.go_name(arg.alias if arg.alias != "" else arg.name)
        file += "\n\n" + Template(WITH_FUNCTION_GO_TMPL).substitute(
            Field=field_name,
            field=field_name[0].lower()
            + field_name[1:]
            + ("_" if field_name == "Type" else ""),
            FieldType=Type.from_name(client, arg.type_name).go_type(
                target_pkg="list", full=True
            ),
        )

    with open(filepath, "w") as f:
        f.write(file)


def write_helper(
    generated_file_header: str, entity_list: list[Entity], kind: str, filepath: Path
) -> None:
    """Writes the helper file for the given kind."""
    external_imports = [
        '"github.com/weisshorn-cyd/gocti/api"',
        '"github.com/weisshorn-cyd/gocti/entity"',
        '"github.com/weisshorn-cyd/gocti/system"',
    ] + (
        [
            '"github.com/weisshorn-cyd/gocti/list"',
            f'"github.com/weisshorn-cyd/gocti/{GRAPHQL_TYPES_PKG_NAME}"',
        ]
        if kind == "list"
        else []
    )
    imports = utils.format_go_imports([['"context"'], external_imports])

    file = (
        generated_file_header
        + "\n\n"
        + Template(GO_CODE_HEADER).substitute(pkg="gocti", imports=imports)
        + "\n\n"
        + "// Helper methods declarations"
    )

    for e in entity_list:
        if kind == "list" and e.list_query is not None:
            file += "\n\n" + e.list_helper()
        elif kind == "read" and e.read_query is not None:
            file += "\n\n" + e.read_helper()
        elif kind == "create" and e.create_query is not None:
            file += "\n\n" + e.create_helper()
        elif kind == "delete" and e.delete_query is not None:
            file += "\n\n" + e.delete_helper()

    with open(filepath, "w") as f:
        f.write(file + "\n")


if __name__ == "__main__":
    print(f"Running 'gocti_type_generator.main.py {" ".join(sys.argv[1:])}'")

    # Load environment and initialise the clients.
    cfg = load_config()

    delete_generated_files(cfg=cfg)

    generated_file_header = build_generated_file_header(cfg)

    print("Loading custom types")
    declare_custom_types(cfg=cfg)

    print("Loading entities")
    base_entities: list[Entity] = [
        Entity(cfg.client, cfg.graphql_queries, e, "entity")
        for e in BASE_ENTITIES + LOW_LEVEL_ENTITIES
    ]
    system_entities: list[Entity] = [
        Entity(cfg.client, cfg.graphql_queries, e, "system") for e in SYSTEM_ENTITIES
    ]
    all_entities: list[Entity] = base_entities + system_entities
    base_entities.sort(key=lambda e: e.name)
    system_entities.sort(key=lambda e: e.name)
    all_entities.sort(key=lambda e: e.name)

    print("Generating entity files")
    write_entities(generated_file_header, base_entities, "entity", cfg.repo)
    write_entities(generated_file_header, system_entities, "system", cfg.repo)

    print("Generating base GraphQL types")
    write_graphql_types(
        generated_file_header, base_entities + system_entities, cfg.repo
    )

    print("Generating list options")
    write_list_options(
        generated_file_header,
        cfg.client,
        base_entities + system_entities,
        Path(cfg.repo, "list", "options.go"),
    )

    print("Generating helpers")
    write_helper(generated_file_header, all_entities, "list", Path(cfg.repo, "list.go"))
    write_helper(generated_file_header, all_entities, "read", Path(cfg.repo, "read.go"))
    write_helper(
        generated_file_header, all_entities, "create", Path(cfg.repo, "create.go")
    )
    write_helper(
        generated_file_header, all_entities, "delete", Path(cfg.repo, "delete.go")
    )
